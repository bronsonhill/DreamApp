import openai
import json
from datetime import datetime



# gpt-3.5-turbo 4k context
MODEL = "gpt-3.5-turbo-0613"
INPUT_COST_P_1000 = 0.0015
OUTPUT_COST_P_1000 = 0.002

# gpt-3.5-turbo 16k context
# MODEL = "gpt-3.5-turbo"
# INPUT_COST_P_1000 = 0.003
# OUTPUT_COST_P_1000 = 0.004

# gpt-4 8k context
# MODEL = "gpt-4"
# INPUT_COST_P_1000 = 0.03
# OUTPUT_COST_P_1000 = 0.06

# gpt-4 32k context
# MODEL = "gpt-4"
# INPUT_COST_P_1000 = 0.06
# OUTPUT_COST_P_1000 = 0.12


USER_ROLE = "user"
AI_ROLE = "assistant"


# open key.txt and save the key
with open("../key.txt", "r") as fp:
    key = fp.read()


# open functions.json and save the functions
with open("Python/data/functions.json", "r") as fp:
    functions = json.load(fp)


# open messages.txt and save the messages
with open("Python/data/messages.json", "r") as fp:
    messages = json.load(fp)


request_log = []
openai.api_key = key


class Dream:
    """
    A class to represent a dream, a piece of fiction generated by GPT
    """

    def __init__(self) -> None:
        """
        initializes the dream
        """
        self.cost = 0
        #self.seed = self.generate_seed()
        self.seed = """Genre: Sci-fi/Fantasy
Setting: A futuristic society where dreams can be harvested as a powerful energy source and consciousness can be altered.
Plot: In a future where dwindling energy resources have led humanity to develop a groundbreaking technology, DreamNet, which allows them to harness dreams as a renewable energy source. The protagonist, a gifted DreamCatcher named Aria, discovers that her dreams hold an unprecedented amount of energy and a mysterious connection to a long-lost civilization.
Characters:
- Aria: The gifted DreamCatcher who possesses extraordinary dream energy and embarks on a quest to uncover the truth about her dreams and their connection to the past.
- Dr. Ethan Blackwell: The renowned scientist who developed DreamNet but becomes increasingly obsessed with the potential power of harvesting dreams, ultimately leading him down a dangerous path.
- Zephyr: A rebellious DreamGuide who challenges the existing power structure and helps Aria reveal the secrets hidden within her dreams.
Point of View: The story is predominantly told from Aria's perspective, offering an intimate exploration of her journey and the revelations she uncovers.
Themes: 
- The power of dreams: Explores the concept of dreams as a source of energy while delving into the symbolic meaning they hold, their ties to individuality, and their influence on our reality.
- Attention and imagination: Explores the theme of attention as a valuable resource, highlighting the importance of cultivating and channeling one's focus and imagination.
Tone and Style: The story balances a sense of wonder and awe with moments of tension and intrigue. The prose embodies a vivid and imaginative style, capturing both the ethereal beauty of dreams and the gritty reality of a future society.
Structure: The story follows Aria's transformative journey as she navigates the complexities of a society dependent on harvesting dreams. It incorporates elements of mystery, exploration, and personal awakening as she unravels the truth behind her unique dream energy and its significance in a grander scheme.
"""

        self.seedling = self.grow_seed(seed=self.seed)
        # self.chapters = self.write_chapters(seedling=self.seedling)

        pass

    def generate_seed(self, recurse=False, seed_messages=[]) -> str:
        """
        generates a seed of a narrative with the inspiration of user 
        input if provided. Also recurses if user is unhappy with result
        """
        description = "generate_seed"
        if not recurse:
            # prompts the user for the seed of the story
            user_message = input(
                "Welcome to Dream.\nLet's write a story together! "
                "Here are some questions that you might like to think "
                "about in forming your vision of the dream to be.\n"
                "What makes a good story? Is there a problem that you'd "
                "like to explore?\nWhat genre do you like? Are there any "
                "stories that particularly resonate with you? Finally, do "
                "you have any ideas when and where the story might be set?\n")

            # gets response from chatcompletion
            seed_messages = messages["generate_seed"]
            append_message(messages=seed_messages, content=user_message, 
                           role=USER_ROLE)
            
            (completion, temp) = chat_completion(messages=seed_messages,
                                                      description=description)
            self.cost += temp

            print(completion)

        # makes edits to the seed until user is happy
        else:
            (completion, temp) = chat_completion(messages=seed_messages, description=description+"_edit")
            self.cost += temp
            print(completion)

        user_message = input("Are you happy with this seed? (y/n)\n")

        # when user is happy with the seed
        if user_message == "y":
            print("Great! Let's plant this seed.")

            return completion
        
        # when user wants to make edits to the seed
        elif user_message == "n":
            user_message = input("What would you like to change?\n")
            user_message = "Generate a new seed taking this into consideration: " + user_message
            append_message(messages=seed_messages, content=user_message, 
                           role=USER_ROLE)
            
            return self.generate_seed(recurse=True, seed_messages=seed_messages)
        
        # when user does not enter y or n
        else:
            print("Please enter y or n.")
            return self.generate_seed(recurse=True, seed_messages=seed_messages)
    
    

    def grow_seed(self, seed):
        """
        creates title and further articulates each point of the seed
        """
        description = "grow_seed"

        seedling_points = {"Genre": "", "Setting": "", "Plot": "",
                           "Characters": "", "Themes": "", "Tone and style": "",
                           "Structure": ""}
        
        seedling_messages = messages["base"]

        for point in seedling_points.keys():
            content = f"Given the following seed of a novel, further articulate the details and plan for the {point} aspect of the story\n{seed}"
            append_message(messages=seedling_messages, content=content, role=USER_ROLE)

            (completion, temp) = chat_completion(messages=seedling_messages, description=description+"_point")
            self.cost += temp
            print(completion)
            seedling_points[point] = completion
            seedling_messages.pop()


        # creates a title for the novel based on seed
        seedling_messages = []
        content = f"Given the following seed of a novel, generate some ideas for a title\n{seed}"

        (completion, temp) = chat_completion(messages=seedling_messages, 
                                                  description=description+"_title")
        self.cost += temp
        print(completion)

        user_input = input("What would you like to call the novel?\n")
        seedling_points["Title"] = user_input
        self.title = user_input

        # saves seedling to a file
        with open("Python/dreams/"+self.title+".txt", "w") as fp:
            for point in seedling_points.items():
                fp.write(f"{point[0]}: {point[1]}\n\n")

        return
    
    
    def write_chapters(self, seedling):
        """
        writes the novel chapter by chapter
        """





class Chapter:
    def __init__(self, seedling, plan) -> None:
        """
        initializes the chapter
        """
        self.seedling = seedling
        self.plan = plan
        pass



class Passage:
    def __init__(self, description, previous_passage, summary) -> None:
        """
        initializes the passage
        """
        pass




def append_message(messages: list, content: str, role: str):
    """
    appends message to messages list
    :param messages: messages list of openai format
    :param message: a message of string format
    :param role: ie. assistant or user
    """

    messages.append(
        {
        "role": role,
        "content": content
        }
    )

    return


def cost_calculation(usage: dict, description: str) -> float:
    """
    calculates the cost of the request
    :param usage: usage dict of openai format
    """
    completion_tokens = 0
    prompt_tokens = 0
    cost = 0

    usage["completion_cost"] = usage["completion_tokens"] * OUTPUT_COST_P_1000 / 1000
    usage["prompt_cost"] = usage["prompt_tokens"] * INPUT_COST_P_1000 / 1000
    usage["cost"] = usage["completion_cost"] + usage["prompt_cost"]
    usage["datetime"] = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    usage["description"] = description

    request_log.append(usage)
    


    return usage["cost"]


def log_requests(requests: list):
    """
    logs requests and prints details
    """
    with open("Python/data/request_log.json", "r") as fp:
        requests = json.load(fp)
        requests += request_log

    json.dump(requests, open("Python/data/request_log.json", "w"), indent=4)

    print("Total requests: ", len(requests))
    print("Total cost: $", sum([request["cost"] for request in requests]))
    print("Total completion tokens: ", sum([request["completion_tokens"] 
                                            for request in requests]))
    print("Total prompt tokens: ", sum([request["prompt_tokens"] 
                                        for request in requests]))


    return


def chat_completion(messages: list, function = [], description = "") -> dict:
    """
    completes the chat
    :param messages: messages list of openai format
    :param max_tokens: max tokens to be used for completion
    :param stop: stop list of openai format
    """

    if not function:
    
        completion = openai.ChatCompletion.create(
            model=MODEL,
            messages=messages,
        )
    
    else:
        completion = openai.ChatCompletion.create(
            model=MODEL,
            messages=messages,
            functions=function,
            function_call=function[0].keys()[0]
        )

    return (completion["choices"][0]["message"]["content"], 
            cost_calculation(completion["usage"], description))




def plan_section():
    """
    plans the section
    """

    return


def edit(seed, context, section):
    """
    edits text according to its context
    """

    return

try:
    myDream = Dream()
    log_requests(requests=request_log)
    
except:
    log_requests(requests=request_log)